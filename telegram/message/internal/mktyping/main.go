package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"reflect"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/go-faster/errors"
	"go.uber.org/multierr"

	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tg"
)

// Field represents type field.
type Field struct {
	// Name is Go name of field.
	Name string
	// Type is Go type of field.
	Type string
}

// Type represents generated type.
type Type struct {
	// Name is Go name of type.
	Name string
	// Fields is slice of type fields.
	Fields []Field
	// SchemaType is related schema type.
	SchemaType tdp.Type
}

// Config is generation config.
type Config struct {
	PackageName string
	Types       []Type
}

const rawTemplate = `// Code generated by mktyping, DO NOT EDIT.
package {{ $.PackageName }}

import (
	"context"

	"github.com/gotd/td/tg"
)

var (
	_ = tg.Invoker(nil)
	_ = context.Context(nil)
)

{{- /*gotype: github.com/gotd/td/telegram/message/internal/mktyping.Config*/ -}}
{{- range $typ := $.Types }}
{{ $helperName := trimSuffix (trimPrefix $typ.Name "SendMessage") "Action" -}}
// {{ $helperName }} sends {{ $typ.Name }}.
func (b *TypingActionBuilder) {{ $helperName }}(ctx context.Context,
{{- range $f := $typ.Fields }}{{ lowerFirst $f.Name }} {{ $f.Type }},{{ end }}) error {
	return b.send(ctx, &tg.{{ $typ.Name }}{
		{{- range $f := $typ.Fields }}
		{{ $f.Name }}: {{ lowerFirst $f.Name }},
		{{- end }}
	})
}
{{- end }}
`

var (
	constructors = tg.ClassConstructorsMap()
	create       = tg.TypesConstructorMap()
)

func generate(w io.Writer, pkgName string) error {
	buf := bytes.Buffer{}

	var types []Type
	for _, typeID := range constructors[tg.SendMessageActionClassName] {
		v, ok := create[typeID]().(tdp.Object)
		if !ok {
			return errors.Errorf("bad type %#x", typeID)
		}
		schemaType := v.TypeInfo()
		tv := reflect.TypeOf(v).Elem()

		var fields []Field
		for _, field := range schemaType.Fields {
			rf, ok := tv.FieldByName(field.Name)
			if !ok {
				return errors.Errorf("field of %q type %q not found", field.Name, schemaType.Name)
			}
			fields = append(fields, Field{
				Name: field.Name,
				Type: rf.Type.String(),
			})
		}
		types = append(types, Type{
			Name:       tv.Name(),
			Fields:     fields,
			SchemaType: v.TypeInfo(),
		})
	}

	t := template.Must(template.New("gen").Funcs(template.FuncMap{
		"trimPrefix": strings.TrimPrefix,
		"trimSuffix": strings.TrimSuffix,
		"lowerFirst": func(s string) string {
			r, size := utf8.DecodeRuneInString(s)
			if r == utf8.RuneError || unicode.IsLower(r) {
				return s
			}
			return string(unicode.ToLower(r)) + s[size:]
		},
	}).Parse(rawTemplate))
	if err := t.Execute(&buf, Config{
		PackageName: pkgName,
		Types:       types,
	}); err != nil {
		return fmt.Errorf("execute: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		_, _ = os.Stderr.Write(buf.Bytes())
		return fmt.Errorf("format: %w", err)
	}

	if _, err := w.Write(formatted); err != nil {
		return fmt.Errorf("write: %w", err)
	}

	return nil
}

func run() (rErr error) {
	var (
		o       = flag.String("output", "", "output file")
		pkgName = flag.String("package", "message", "package name")
	)
	flag.Parse()

	var w io.Writer = os.Stdout
	if path := *o; path != "" {
		f, err := os.Create(path)
		if err != nil {
			return err
		}
		defer multierr.AppendInvoke(&rErr, multierr.Close(f))
		w = f
	}

	return generate(w, *pkgName)
}

func main() {
	if err := run(); err != nil {
		panic(err)
	}
}
