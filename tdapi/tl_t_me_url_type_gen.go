// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// TMeURLTypeUser represents TL type `tMeUrlTypeUser#b88d499e`.
type TMeURLTypeUser struct {
	// Identifier of the user
	UserID int32
}

// TMeURLTypeUserTypeID is TL type id of TMeURLTypeUser.
const TMeURLTypeUserTypeID = 0xb88d499e

// construct implements constructor of TMeURLTypeClass.
func (t TMeURLTypeUser) construct() TMeURLTypeClass { return &t }

// Ensuring interfaces in compile-time for TMeURLTypeUser.
var (
	_ bin.Encoder     = &TMeURLTypeUser{}
	_ bin.Decoder     = &TMeURLTypeUser{}
	_ bin.BareEncoder = &TMeURLTypeUser{}
	_ bin.BareDecoder = &TMeURLTypeUser{}

	_ TMeURLTypeClass = &TMeURLTypeUser{}
)

func (t *TMeURLTypeUser) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TMeURLTypeUser) String() string {
	if t == nil {
		return "TMeURLTypeUser(nil)"
	}
	type Alias TMeURLTypeUser
	return fmt.Sprintf("TMeURLTypeUser%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TMeURLTypeUser) TypeID() uint32 {
	return TMeURLTypeUserTypeID
}

// TypeName returns name of type in TL schema.
func (*TMeURLTypeUser) TypeName() string {
	return "tMeUrlTypeUser"
}

// TypeInfo returns info about TL type.
func (t *TMeURLTypeUser) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "tMeUrlTypeUser",
		ID:   TMeURLTypeUserTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TMeURLTypeUser) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeUser#b88d499e as nil")
	}
	b.PutID(TMeURLTypeUserTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TMeURLTypeUser) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeUser#b88d499e as nil")
	}
	b.PutInt32(t.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TMeURLTypeUser) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeUser#b88d499e to nil")
	}
	if err := b.ConsumeID(TMeURLTypeUserTypeID); err != nil {
		return fmt.Errorf("unable to decode tMeUrlTypeUser#b88d499e: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TMeURLTypeUser) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeUser#b88d499e to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode tMeUrlTypeUser#b88d499e: field user_id: %w", err)
		}
		t.UserID = value
	}
	return nil
}

// GetUserID returns value of UserID field.
func (t *TMeURLTypeUser) GetUserID() (value int32) {
	return t.UserID
}

// TMeURLTypeSupergroup represents TL type `tMeUrlTypeSupergroup#af5536a8`.
type TMeURLTypeSupergroup struct {
	// Identifier of the supergroup or channel
	SupergroupID int64
}

// TMeURLTypeSupergroupTypeID is TL type id of TMeURLTypeSupergroup.
const TMeURLTypeSupergroupTypeID = 0xaf5536a8

// construct implements constructor of TMeURLTypeClass.
func (t TMeURLTypeSupergroup) construct() TMeURLTypeClass { return &t }

// Ensuring interfaces in compile-time for TMeURLTypeSupergroup.
var (
	_ bin.Encoder     = &TMeURLTypeSupergroup{}
	_ bin.Decoder     = &TMeURLTypeSupergroup{}
	_ bin.BareEncoder = &TMeURLTypeSupergroup{}
	_ bin.BareDecoder = &TMeURLTypeSupergroup{}

	_ TMeURLTypeClass = &TMeURLTypeSupergroup{}
)

func (t *TMeURLTypeSupergroup) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.SupergroupID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TMeURLTypeSupergroup) String() string {
	if t == nil {
		return "TMeURLTypeSupergroup(nil)"
	}
	type Alias TMeURLTypeSupergroup
	return fmt.Sprintf("TMeURLTypeSupergroup%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TMeURLTypeSupergroup) TypeID() uint32 {
	return TMeURLTypeSupergroupTypeID
}

// TypeName returns name of type in TL schema.
func (*TMeURLTypeSupergroup) TypeName() string {
	return "tMeUrlTypeSupergroup"
}

// TypeInfo returns info about TL type.
func (t *TMeURLTypeSupergroup) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "tMeUrlTypeSupergroup",
		ID:   TMeURLTypeSupergroupTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SupergroupID",
			SchemaName: "supergroup_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TMeURLTypeSupergroup) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeSupergroup#af5536a8 as nil")
	}
	b.PutID(TMeURLTypeSupergroupTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TMeURLTypeSupergroup) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeSupergroup#af5536a8 as nil")
	}
	b.PutLong(t.SupergroupID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TMeURLTypeSupergroup) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeSupergroup#af5536a8 to nil")
	}
	if err := b.ConsumeID(TMeURLTypeSupergroupTypeID); err != nil {
		return fmt.Errorf("unable to decode tMeUrlTypeSupergroup#af5536a8: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TMeURLTypeSupergroup) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeSupergroup#af5536a8 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode tMeUrlTypeSupergroup#af5536a8: field supergroup_id: %w", err)
		}
		t.SupergroupID = value
	}
	return nil
}

// GetSupergroupID returns value of SupergroupID field.
func (t *TMeURLTypeSupergroup) GetSupergroupID() (value int64) {
	return t.SupergroupID
}

// TMeURLTypeChatInvite represents TL type `tMeUrlTypeChatInvite#12b5da49`.
type TMeURLTypeChatInvite struct {
	// Chat invite link info
	Info ChatInviteLinkInfo
}

// TMeURLTypeChatInviteTypeID is TL type id of TMeURLTypeChatInvite.
const TMeURLTypeChatInviteTypeID = 0x12b5da49

// construct implements constructor of TMeURLTypeClass.
func (t TMeURLTypeChatInvite) construct() TMeURLTypeClass { return &t }

// Ensuring interfaces in compile-time for TMeURLTypeChatInvite.
var (
	_ bin.Encoder     = &TMeURLTypeChatInvite{}
	_ bin.Decoder     = &TMeURLTypeChatInvite{}
	_ bin.BareEncoder = &TMeURLTypeChatInvite{}
	_ bin.BareDecoder = &TMeURLTypeChatInvite{}

	_ TMeURLTypeClass = &TMeURLTypeChatInvite{}
)

func (t *TMeURLTypeChatInvite) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Info.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TMeURLTypeChatInvite) String() string {
	if t == nil {
		return "TMeURLTypeChatInvite(nil)"
	}
	type Alias TMeURLTypeChatInvite
	return fmt.Sprintf("TMeURLTypeChatInvite%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TMeURLTypeChatInvite) TypeID() uint32 {
	return TMeURLTypeChatInviteTypeID
}

// TypeName returns name of type in TL schema.
func (*TMeURLTypeChatInvite) TypeName() string {
	return "tMeUrlTypeChatInvite"
}

// TypeInfo returns info about TL type.
func (t *TMeURLTypeChatInvite) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "tMeUrlTypeChatInvite",
		ID:   TMeURLTypeChatInviteTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Info",
			SchemaName: "info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TMeURLTypeChatInvite) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeChatInvite#12b5da49 as nil")
	}
	b.PutID(TMeURLTypeChatInviteTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TMeURLTypeChatInvite) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeChatInvite#12b5da49 as nil")
	}
	if err := t.Info.Encode(b); err != nil {
		return fmt.Errorf("unable to encode tMeUrlTypeChatInvite#12b5da49: field info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TMeURLTypeChatInvite) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeChatInvite#12b5da49 to nil")
	}
	if err := b.ConsumeID(TMeURLTypeChatInviteTypeID); err != nil {
		return fmt.Errorf("unable to decode tMeUrlTypeChatInvite#12b5da49: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TMeURLTypeChatInvite) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeChatInvite#12b5da49 to nil")
	}
	{
		if err := t.Info.Decode(b); err != nil {
			return fmt.Errorf("unable to decode tMeUrlTypeChatInvite#12b5da49: field info: %w", err)
		}
	}
	return nil
}

// GetInfo returns value of Info field.
func (t *TMeURLTypeChatInvite) GetInfo() (value ChatInviteLinkInfo) {
	return t.Info
}

// TMeURLTypeStickerSet represents TL type `tMeUrlTypeStickerSet#5f83ccec`.
type TMeURLTypeStickerSet struct {
	// Identifier of the sticker set
	StickerSetID Int64
}

// TMeURLTypeStickerSetTypeID is TL type id of TMeURLTypeStickerSet.
const TMeURLTypeStickerSetTypeID = 0x5f83ccec

// construct implements constructor of TMeURLTypeClass.
func (t TMeURLTypeStickerSet) construct() TMeURLTypeClass { return &t }

// Ensuring interfaces in compile-time for TMeURLTypeStickerSet.
var (
	_ bin.Encoder     = &TMeURLTypeStickerSet{}
	_ bin.Decoder     = &TMeURLTypeStickerSet{}
	_ bin.BareEncoder = &TMeURLTypeStickerSet{}
	_ bin.BareDecoder = &TMeURLTypeStickerSet{}

	_ TMeURLTypeClass = &TMeURLTypeStickerSet{}
)

func (t *TMeURLTypeStickerSet) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.StickerSetID.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TMeURLTypeStickerSet) String() string {
	if t == nil {
		return "TMeURLTypeStickerSet(nil)"
	}
	type Alias TMeURLTypeStickerSet
	return fmt.Sprintf("TMeURLTypeStickerSet%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TMeURLTypeStickerSet) TypeID() uint32 {
	return TMeURLTypeStickerSetTypeID
}

// TypeName returns name of type in TL schema.
func (*TMeURLTypeStickerSet) TypeName() string {
	return "tMeUrlTypeStickerSet"
}

// TypeInfo returns info about TL type.
func (t *TMeURLTypeStickerSet) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "tMeUrlTypeStickerSet",
		ID:   TMeURLTypeStickerSetTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StickerSetID",
			SchemaName: "sticker_set_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TMeURLTypeStickerSet) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeStickerSet#5f83ccec as nil")
	}
	b.PutID(TMeURLTypeStickerSetTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TMeURLTypeStickerSet) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode tMeUrlTypeStickerSet#5f83ccec as nil")
	}
	if err := t.StickerSetID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode tMeUrlTypeStickerSet#5f83ccec: field sticker_set_id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TMeURLTypeStickerSet) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeStickerSet#5f83ccec to nil")
	}
	if err := b.ConsumeID(TMeURLTypeStickerSetTypeID); err != nil {
		return fmt.Errorf("unable to decode tMeUrlTypeStickerSet#5f83ccec: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TMeURLTypeStickerSet) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode tMeUrlTypeStickerSet#5f83ccec to nil")
	}
	{
		if err := t.StickerSetID.Decode(b); err != nil {
			return fmt.Errorf("unable to decode tMeUrlTypeStickerSet#5f83ccec: field sticker_set_id: %w", err)
		}
	}
	return nil
}

// GetStickerSetID returns value of StickerSetID field.
func (t *TMeURLTypeStickerSet) GetStickerSetID() (value Int64) {
	return t.StickerSetID
}

// TMeURLTypeClass represents TMeUrlType generic type.
//
// Example:
//  g, err := tdapi.DecodeTMeURLType(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tdapi.TMeURLTypeUser: // tMeUrlTypeUser#b88d499e
//  case *tdapi.TMeURLTypeSupergroup: // tMeUrlTypeSupergroup#af5536a8
//  case *tdapi.TMeURLTypeChatInvite: // tMeUrlTypeChatInvite#12b5da49
//  case *tdapi.TMeURLTypeStickerSet: // tMeUrlTypeStickerSet#5f83ccec
//  default: panic(v)
//  }
type TMeURLTypeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() TMeURLTypeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeTMeURLType implements binary de-serialization for TMeURLTypeClass.
func DecodeTMeURLType(buf *bin.Buffer) (TMeURLTypeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case TMeURLTypeUserTypeID:
		// Decoding tMeUrlTypeUser#b88d499e.
		v := TMeURLTypeUser{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TMeURLTypeClass: %w", err)
		}
		return &v, nil
	case TMeURLTypeSupergroupTypeID:
		// Decoding tMeUrlTypeSupergroup#af5536a8.
		v := TMeURLTypeSupergroup{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TMeURLTypeClass: %w", err)
		}
		return &v, nil
	case TMeURLTypeChatInviteTypeID:
		// Decoding tMeUrlTypeChatInvite#12b5da49.
		v := TMeURLTypeChatInvite{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TMeURLTypeClass: %w", err)
		}
		return &v, nil
	case TMeURLTypeStickerSetTypeID:
		// Decoding tMeUrlTypeStickerSet#5f83ccec.
		v := TMeURLTypeStickerSet{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TMeURLTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode TMeURLTypeClass: %w", bin.NewUnexpectedID(id))
	}
}

// TMeURLType boxes the TMeURLTypeClass providing a helper.
type TMeURLTypeBox struct {
	TMeUrlType TMeURLTypeClass
}

// Decode implements bin.Decoder for TMeURLTypeBox.
func (b *TMeURLTypeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode TMeURLTypeBox to nil")
	}
	v, err := DecodeTMeURLType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.TMeUrlType = v
	return nil
}

// Encode implements bin.Encode for TMeURLTypeBox.
func (b *TMeURLTypeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.TMeUrlType == nil {
		return fmt.Errorf("unable to encode TMeURLTypeClass as nil")
	}
	return b.TMeUrlType.Encode(buf)
}
